<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Fit Astrometry · DirectDetections.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.039/juliamono-regular.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">DirectDetections.jl</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../getting-started/">Getting Started</a></li><li><span class="tocitem">Tutorials</span><ul><li class="is-active"><a class="tocitem" href>Fit Astrometry</a><ul class="internal"><li><a class="tocitem" href="#Creating-a-planet"><span>Creating a planet</span></a></li><li><a class="tocitem" href="#Creating-a-system"><span>Creating a system</span></a></li><li><a class="tocitem" href="#Sampling"><span>Sampling</span></a></li><li><a class="tocitem" href="#Diagnostics"><span>Diagnostics</span></a></li><li><a class="tocitem" href="#Analysis"><span>Analysis</span></a></li><li><a class="tocitem" href="#Pair-Plot"><span>Pair Plot</span></a></li><li><a class="tocitem" href="#Notes-on-Hamiltonian-Monte-Carlo"><span>Notes on Hamiltonian Monte Carlo</span></a></li></ul></li><li><a class="tocitem" href="../pma/">Fit Astrometric Acceleration</a></li><li><a class="tocitem" href="../images/">Fit Images</a></li><li><a class="tocitem" href="../derived/">Derived Variables</a></li><li><a class="tocitem" href="../mass-photometry/">Connecting Mass with Photometry</a></li><li><a class="tocitem" href="../loading-saving/">Loading and Saving Data</a></li></ul></li><li><span class="tocitem">Documentation</span><ul><li><a class="tocitem" href="../priors/">Priors</a></li><li><a class="tocitem" href="../samplers/">Samplers</a></li><li><a class="tocitem" href="../chains/">Chains</a></li><li><a class="tocitem" href="../kepler/">Kepler Solver</a></li><li><a class="tocitem" href="../api/">API</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Tutorials</a></li><li class="is-active"><a href>Fit Astrometry</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Fit Astrometry</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/sefffal/DirectDetections.jl/blob/master/docs/src/modelling.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="fit-astrometry"><a class="docs-heading-anchor" href="#fit-astrometry">Fitting Astrometry</a><a id="fit-astrometry-1"></a><a class="docs-heading-anchor-permalink" href="#fit-astrometry" title="Permalink"></a></h1><p>Here is a worked example of a basic model. It contains a star with a single planet, and several astrometry points.</p><p>The full code is available on <a href="https://github.com/sefffal/DirectDetections.jl/examples/basic-example.jl">GitHub</a></p><p>Start by loading the DirectDetections and Plots packages:</p><pre><code class="language-julia hljs">using DirectDetections, Distributions, Plots</code></pre><h2 id="Creating-a-planet"><a class="docs-heading-anchor" href="#Creating-a-planet">Creating a planet</a><a id="Creating-a-planet-1"></a><a class="docs-heading-anchor-permalink" href="#Creating-a-planet" title="Permalink"></a></h2><p>Create our first planet. Let&#39;s name it planet X.</p><pre><code class="language-julia hljs">@named X = Planet(
    Priors(
        a = TruncatedNormal(1, 0.5, 0, Inf),
        e = TruncatedNormal(0.0, 0.2, 0, 1.0),
        τ = Normal(0.5, 1),
        ω = Normal(deg2rad(250.), deg2rad(80.)),
        i = Normal(deg2rad(20.), deg2rad(10.)),
        Ω = Normal(deg2rad(200.), deg2rad(30.)),
    ),
    Astrometry(
        (epoch=5000.,  ra=-364., dec=-1169., σ_ra=70., σ_dec=30.),
        (epoch=5014.,  ra=-493., dec=-1104., σ_ra=70., σ_dec=30.),
        (epoch=5072.,  ra=-899., dec=-629., σ_ra=10., σ_dec=50.),
    )
)</code></pre><p>There&#39;s a lot going on here, so let&#39;s break it down.</p><p>The <code>Priors</code> block accepts the priors that you would like for the orbital parameters of this planet. Priors can be any univariate distribution from the Distributions.jl package. You will want to always specify the following parameters:</p><ul><li><code>a</code>: Semi-major axis, astronomical units (AU)</li><li><code>i</code>: Inclination, radius</li><li><code>e</code>: Eccentricity in the range [0, 1)</li><li><code>τ</code>: Epoch of periastron passage, in fraction of orbit [0,1] (periodic outside these bounds)</li><li><code>ω</code>: Argument of periastron, radius</li><li><code>Ω</code>: Longitude of the ascending node, radians.</li></ul><p>The parameter τ represents the epoch of periastron passage as a fraction of the planet&#39;s orbit between 0 and 1. This follows the same convention as Orbitize! and you can read more about their choice in ther FAQ.</p><p>The parameters can be specified in any order.</p><p>The <code>Astrometry</code> block is optional. This is where you can list the position of a planet at different epochs if it known. <code>epoch</code> is a modified Julian date that the observation was taken. the <code>ra</code>, <code>dec</code>, <code>σ_ra</code>, and <code>σ_dec</code> parameters are the position of the planet at that epoch, relative to the star. All values in milliarcseconds (mas).</p><p>Many different distributions are supported as priors, including <code>Uniform</code>, <code>LogNormal</code>, <code>LogUniform</code>, <code>Sine</code>, and <code>Beta</code>. See the section on <a href="../priors/#priors">Priors</a> for more information.</p><h2 id="Creating-a-system"><a class="docs-heading-anchor" href="#Creating-a-system">Creating a system</a><a id="Creating-a-system-1"></a><a class="docs-heading-anchor-permalink" href="#Creating-a-system" title="Permalink"></a></h2><p>A system represents a host star with one or more planets. Properties of the whole system are specified here, like parallax distance and mass of the star. This is also where you will supply data like images and astrometric acceleration in later tutorials, since those don&#39;t belong to any planet in particular.</p><pre><code class="language-julia hljs">@named HD82134 = System(
    Priors(
        μ = Normal(1.0, 0.01),
        plx =Normal(1000.2, 0.02),
    ),  
    X,
)</code></pre><p>The <code>Priors</code> block works just like it does for planets. Here, the two parameters you must provide are:</p><ul><li><code>μ</code>: Gravitational parameter of the central body, expressed in units of Solar mass.</li><li><code>plx</code>: Distance to the system expressed in milliarcseconds of parallax.</li></ul><p>After that, just list any planets that you want orbiting the star. Here, we pass planet X.</p><p>You can name the system and planets whatever you like. NB: the <code>@named</code> convenience macro just passes in the name as a keyword argument, e.g. <code>name=:HD82134</code>. This makes sure that the variable name matches what gets displayed in the package output, and saved a few keystrokes. (taken from ModellingToolkit.jl)</p><h2 id="Sampling"><a class="docs-heading-anchor" href="#Sampling">Sampling</a><a id="Sampling-1"></a><a class="docs-heading-anchor-permalink" href="#Sampling" title="Permalink"></a></h2><p>Great! Now we are ready to draw samples from the posterior.</p><p>Start sampling:</p><pre><code class="language-julia hljs">chain = DirectDetections.hmc(
    HD82134,
    adaptation =   8_000,
    iterations = 100_000,
);</code></pre><p>You will get an output that looks something like with a progress bar that updates every second or so:</p><pre><code class="nohighlight hljs">┌ Info: Guessing a good starting location by sampling from priors
└   N = 500000
┌ Info: Found initial stepsize
└   initial_ϵ = 2.44140625e-5
[ Info: Will adapt step size and mass matrix
[ Info: progress logging is enabled globally
Sampling100%|███████████████████████████████| Time: 0:03:43
[ Info: Sampling compete. Building chains.
Sampling report for chain 1:
mean_accept =         0.926384435746952
num_err_frac =        0.0
mean_tree_depth =     7.072923809523809
max_tree_depth_frac = 0.0

Chains MCMC chain (105000×8×1 Array{Float64, 3}):

Iterations        = 1:1:105000
Number of chains  = 1
Samples per chain = 105000
Wall duration     = 215.28 seconds
Compute duration  = 215.28 seconds
parameters        = μ, plx, X[a], X[e], X[τ], X[ω], X[i], X[Ω]

Summary Statistics
  parameters        mean       std   naive_se      mcse          ess      rhat   ess_per_sec 
      Symbol     Float64   Float64    Float64   Float64      Float64   Float64       Float64 

           μ      0.9991    0.0100     0.0000    0.0000   73497.2356    1.0000      341.4109
         plx   1000.2001    0.0201     0.0001    0.0001   71398.1409    1.0000      331.6602
        X[a]      1.1400    0.0073     0.0000    0.0000   73252.1068    1.0000      340.2722
        X[e]      0.1300    0.0715     0.0002    0.0005   22658.1132    1.0005      105.2519
        X[τ]      0.5019    1.0032     0.0031    0.0039   72030.3424    1.0000      334.5969
        X[ω]      3.5913    0.7692     0.0024    0.0057   16317.8944    1.0000       75.8002
        X[i]      0.7151    0.0596     0.0002    0.0003   49773.0387    1.0000      231.2068
        X[Ω]      3.3891    0.2884     0.0009    0.0023   14232.4927    1.0001       66.1131

Quantiles
  parameters        2.5%       25.0%       50.0%       75.0%       97.5% 
      Symbol     Float64     Float64     Float64     Float64     Float64 

           μ      0.9795      0.9924      0.9991      1.0059      1.0188
         plx   1000.1607   1000.1865   1000.2000   1000.2136   1000.2395
        X[a]      1.1257      1.1350      1.1399      1.1449      1.1544
        X[e]      0.0419      0.0793      0.1090      0.1636      0.3154
        X[τ]     -1.4665     -0.1724      0.5005      1.1751      2.4657
        X[ω]      1.8839      3.0722      3.8094      4.2234      4.5469
        X[i]      0.5929      0.6765      0.7172      0.7559      0.8261
        X[Ω]      2.7051      3.2433      3.4295      3.5671      3.8877</code></pre><p>The sampler will begin by drawing orbits randomly from the priors (50,000 by default). It will then pick the orbit with the highest posterior density as a starting point for HMC adaptation. This recipe is a good way to find a point somewhat close to the typical set. Starting at the global maximum on the other hand, has at times not led to good sampling.</p><p>Once complete, the <code>chain</code> object will hold the sampler results. Displaying it prints out a summary table like the one shown above.</p><p>For a basic model like this, sampling should take less than a minute on a typical laptop.</p><h2 id="Diagnostics"><a class="docs-heading-anchor" href="#Diagnostics">Diagnostics</a><a id="Diagnostics-1"></a><a class="docs-heading-anchor-permalink" href="#Diagnostics" title="Permalink"></a></h2><p>The first thing you should do with your results is check a few diagnostics to make sure the sampler converged as intended.</p><p>A few things to watch out for: check that you aren&#39;t getting many (any, really) numerical errors (<code>num_err_frac</code>). This likely means your priors include values that are not possible/supported like an eccentricity outside [0,1), or a negative semi-major axis. </p><p>One common mistake is to use a distribution like <code>Normal(10,3)</code> for semi-major axis. This left hand side of this distribution includes negative values which are not physically possible. A better choice is a <code>TruncatedNormal(10,3,0,Inf)</code> distribution.</p><p>You may see some warnings during initial step-size adaptation. These are probably nothing to worry about if sampling proceeds normally afterwards.</p><p>You should also check the acceptance rate (<code>mean_accept</code>) is reasonably high and the mean tree depth (<code>mean_tree_depth</code>) is reasonable (~4-8).  Lower than this and the sampler is taking steps that are too large and encountering a U-turn very quicky. Much larger than this and it might be being too conservative. The default maximum tree depth is 10. It should not average anything close to this value, but occasional high values are okay.</p><p>The rate at which the maximum tree depth is hit is <code>max_tree_dept_frac</code> and should be quite low. Reaching the maximum tree depth does not invalidate the results, but does lower the sampling efficiency.</p><p>Next, you can make a trace plot of different variabes to visually inspect the chain:</p><pre><code class="language-julia hljs">plot(
    chain[&quot;X[a]&quot;],
    xlabel=&quot;iteration&quot;,
    ylabel=&quot;semi-major axis (aU)&quot;
)</code></pre><p><img src="../assets/astrometry-trace-plot.png" alt="trace plot"/></p><p>And an auto-correlation plot:</p><pre><code class="language-julia hljs">using StatsBase
plot(
    autocor(chain[&quot;X[e]&quot;, 1:500),
    xlabel=&quot;lag&quot;,
    ylabel=&quot;autocorrelation&quot;,
)</code></pre><p>This plot shows that these samples are not correlated after only above 5 steps. No thinning is necessary. <img src="../assets/astrometry-autocor-plot.png" alt="autocorrelation plot"/></p><p>To confirm convergence, you may also examine the <code>rhat</code> column from chains. This diagnostic approaches 1 as the chains converge and should at the very least equal <code>1.0</code> to one significant digit (3 recommended).</p><p>Finnaly, if you ran multiple chains (see later tutorials to learn how), you can run </p><pre><code class="language-julia hljs">using MCMCChains
gelmandiag(chain)</code></pre><p>As an additional convergence test.</p><h2 id="Analysis"><a class="docs-heading-anchor" href="#Analysis">Analysis</a><a id="Analysis-1"></a><a class="docs-heading-anchor-permalink" href="#Analysis" title="Permalink"></a></h2><p>As a first pass, let&#39;s plot a sample of orbits drawn from the posterior.</p><pre><code class="language-julia hljs">using Plots
plotmodel(HD82134)</code></pre><p>This function draws orbits from the posterior and displays them in a plot. Any astrometry points are overplotted. If other data like astrometric acceleration is provided, additional panels will appear. <img src="../assets/astrometry-model-plot.png" alt="model plot"/></p><h2 id="Pair-Plot"><a class="docs-heading-anchor" href="#Pair-Plot">Pair Plot</a><a id="Pair-Plot-1"></a><a class="docs-heading-anchor-permalink" href="#Pair-Plot" title="Permalink"></a></h2><p>A very useful visualization of our results is a pair-plot, or corner plot. We can use our PairPlots.jl package for this purpose:</p><pre><code class="language-julia hljs">using Plots, PairPlots
table = (;
    a=         chain[&quot;X[a]&quot;],
    e=         chain[&quot;X[e]&quot;],
    i=rad2deg.(chain[&quot;X[i]&quot;]),
    Ω=rad2deg.(chain[&quot;X[Ω]&quot;]),
    ω=rad2deg.(chain[&quot;X[ω]&quot;]),
    τ=         chain[&quot;X[τ]&quot;],
)
labels=[&quot;a&quot;, &quot;e&quot;, &quot;i&quot;, &quot;\\Omega&quot;, &quot;\\omega&quot;, &quot;\\tau&quot;]
units = [&quot;(au)&quot;, &quot;&quot;, &quot;(\\degree)&quot;, &quot;(\\degree)&quot;, &quot;(\\degree)&quot;, &quot;&quot;]
PairPlots.corner(table, labels, units)</code></pre><p>You can read more about the syntax for creating pair plots in the PairPlots.jl documentation page. <a href="../assets/astrometry-corner-plot.svg"><img src="../assets/astrometry-corner-plot.png" alt="corner plot"/></a> In this case, the sampler was able to resolve the complicated degeneracies between eccentricity, the longitude of the ascending node, and argument of periapsis.</p><h2 id="Notes-on-Hamiltonian-Monte-Carlo"><a class="docs-heading-anchor" href="#Notes-on-Hamiltonian-Monte-Carlo">Notes on Hamiltonian Monte Carlo</a><a id="Notes-on-Hamiltonian-Monte-Carlo-1"></a><a class="docs-heading-anchor-permalink" href="#Notes-on-Hamiltonian-Monte-Carlo" title="Permalink"></a></h2><p>Traditional Affine Invariant MCMC is supported (similar to the python <code>emcee</code> package), but it is recommended that you use Hamiltonian Monte Carlo. This sampling method makes use of derivative information, and is much more efficient. This package by default uses the No U-Turn sampler, as implemented in AdvancedHMC.jl.</p><p>Derviatives for a complex model are usualy tedious to code, but DirectDetections uses ForwardDiff.jl to generate them automatically.</p><p>When using HMC, only a few chains are necessary. This is in contrast to Affine Invariant MCMC based packages where hundreds or thousands of walkers are required. One chain should be enough to cover the whole posterior, but you can run a few different chains to make sure each has converged to the same distribution.</p><p>Similarily, many fewer samples are required. This is because unlike Affine Invariant MCMC, HMC produces samples that are much less correlated after each step (i.e. the autocorrelation time is much shorter).</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../getting-started/">« Getting Started</a><a class="docs-footer-nextpage" href="../pma/">Fit Astrometric Acceleration »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.14 on <span class="colophon-date" title="Wednesday 2 March 2022 20:00">Wednesday 2 March 2022</span>. Using Julia version 1.7.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
